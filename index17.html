<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Colorful Dots Background</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            cursor: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .wrapper {
            position: relative;
            width: 80%;
            height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .content {
            position: relative;
            z-index: 10;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            color: white;
            font-family: 'Arial', sans-serif;
            text-align: center;
            max-width: 600px;
        }

        .content h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(to right, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .content p {
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            mix-blend-mode: difference;
            pointer-events: none;
            z-index: 100;
            transition: transform 0.1s;
        }
        .cursor.active {
            transform: scale(2);
            opacity: 0;
            transition: transform 0.5s, opacity 0.5s;
        }

        .dot-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .dot {
            position: absolute;
            border-radius: 50%;
            filter: blur(1px);
            animation: float 15s infinite linear;
            opacity: 0.9;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0);
            }
            25% {
                transform: translate(5px, 10px);
            }
            50% {
                transform: translate(-5px, -10px);
            }
            75% {
                transform: translate(10px, -5px);
            }
        }

    </style>
</head>
<body>
    <div class="cursor"></div>
    <div class="dot-container" id="dotContainer"></div>  
    <div class="wrapper"> </div>
<script>
        // Configuration
        const config = {
            dotCount: 100,
            minSize: 3,
            maxSize: 12,
            baseForce: 0.3,
            repelRadius: 200,
            colors: [
                '#FF3366', '#33FFCC', '#3366FF', '#FF33CC', 
                '#33FF66', '#9966FF', '#66FF33', '#FF6633'
            ]
        };

        // Track cursor position and velocity
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let lastMouseX = mouseX;
        let lastMouseY = mouseY;
        let velocityX = 0;
        let velocityY = 0;

        // Dot collection
        let dots = [];
        let dotContainer = document.getElementById('dotContainer');
        let dotCountDisplay = document.getElementById('dotCount');

        // Create dots
        function createDot() {
            const dot = document.createElement('div');
            dot.className = 'dot';
            
            // Random properties
            const size = randomBetween(config.minSize, config.maxSize);
            const color = config.colors[Math.floor(Math.random() * config.colors.length)];
            
            dot.style.width = `${size}px`;
            dot.style.height = `${size}px`;
            dot.style.backgroundColor = color;
            dot.style.left = `${randomBetween(0, window.innerWidth)}px`;
            dot.style.top = `${randomBetween(0, window.innerHeight)}px`;
            
            // Store properties
            dot.data = {
                x: parseFloat(dot.style.left),
                y: parseFloat(dot.style.top),
                vx: randomBetween(-0.5, 0.5),
                vy: randomBetween(-0.5, 0.5),
                originalColor: color,
                floatingForce: randomBetween(1, 3) / 100,
                createdAt: Date.now()
            };
            
            dotContainer.appendChild(dot);
            
            // Set timeout to fade out after 20 seconds
            setTimeout(() => {
                dot.style.transition = 'opacity 1.5s';
                dot.style.opacity = 0;
                setTimeout(() => {
                    dot.remove();
                    dots = dots.filter(d => d !== dot);
                }, 1500);
            }, 20000 - Math.random() * 6000); // Slightly randomize fade times
            
            return dot;
        }

        function randomBetween(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Initialize dots
        function initDots(count) {
            // Clear existing dots
            dotContainer.innerHTML = '';
            dots = [];
            
            // Create new dots
            for (let i = 0; i < count; i++) {
                dots.push(createDot());
            }
        }

        // Update dot positions
        function updateDots() {
            dots.forEach(dot => {
                const data = dot.data;
                
                // Apply floating animation forces
                data.vx += randomBetween(-data.floatingForce, data.floatingForce);
                data.vy += randomBetween(-data.floatingForce, data.floatingForce);
                
                // Calculate distance to cursor
                const dx = mouseX - data.x;
                const dy = mouseY - data.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Attract dots to cursor when moving
                if (distance > 0) {
                    const followForce = 0.1;
                    const fx = followForce * (mouseX - data.x) / distance;
                    const fy = followForce * (mouseY - data.y) / distance;
                    
                    // Scale force based on cursor speed
                    const speedFactor = Math.min(2, Math.sqrt(velocityX*velocityX + velocityY*velocityY)/10);
                    data.vx += fx * (1 + speedFactor);
                    data.vy += fy * (1 + speedFactor);
                    
                    // Change color when interacting with cursor
                    let opacity = 0.7 + (config.repelRadius - distance) / config.repelRadius * 0.5;
                    dot.style.opacity = opacity;
                    
                    // Add a subtle glow
                    dot.style.boxShadow = `0 0 ${data.size * 2}px ${data.originalColor}`;//Here i did data.size that's why the dots are moving with the cursor 
                } else {
                    // Reset effects
                    dot.style.opacity = 0.9;
                    dot.style.boxShadow = 'none';
                }
                
                // Apply damping to gradually reduce velocity
                data.vx *= 0.98;
                data.vy *= 0.98;
                
                // Update position
                data.x += data.vx;
                data.y += data.vy;
                
                // Wrap around edges
                if (data.x > window.innerWidth) data.x = 0;
                if (data.x < 0) data.x = window.innerWidth;
                if (data.y > window.innerHeight) data.y = 0;
                if (data.y < 0) data.y = window.innerHeight;
                
                // Apply to DOM
                dot.style.left = `${data.x}px`;
                dot.style.top = `${data.y}px`;
            });
            
            requestAnimationFrame(updateDots);
        }

        // Track cursor position and velocity
        function trackCursor(e) {
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            // Calculate velocity
            velocityX = mouseX - lastMouseX;
            velocityY = mouseY - lastMouseY;
            
            // Update custom cursor position
            const cursor = document.querySelector('.cursor');
            cursor.style.left = `${mouseX - 10}px`;
            cursor.style.top = `${mouseY - 10}px`;
            
            // Make leading dots follow cursor more closely
            dots.sort((a,b) => {
                const distA = Math.sqrt(Math.pow(mouseX - a.data.x, 2) + Math.pow(mouseY - a.data.y, 2));
                const distB = Math.sqrt(Math.pow(mouseX - b.data.x, 2) + Math.pow(mouseY - b.data.y, 2));
                return distA - distB;
            });
            
            // Apply force to closest 20% of dots
            const leadDots = Math.floor(dots.length * 0.2);
            dots.slice(0, leadDots).forEach(dot => {
                dot.data.vx += velocityX * 0.05;
                dot.data.vy += velocityY * 0.05;
            });
            
            // Apply push force to nearby dots based on cursor speed
            dots.forEach(dot => {
                const dist = Math.sqrt(Math.pow(mouseX - dot.data.x, 2) + Math.pow(mouseY - dot.data.y, 2));
                if (dist < config.repelRadius * 2) {
                    const speedBoost = Math.min(1.5, Math.sqrt(velocityX * velocityX + velocityY * velocityY) / 10);
                    dot.data.vx += velocityX * speedBoost * 0.3;
                    dot.data.vy += velocityY * speedBoost * 0.3;
                }
            });
        }

        // Resize handler
        function handleResize() {
            dots.forEach(dot => {
                if (dot.data.x > window.innerWidth) dot.data.x = window.innerWidth;
                if (dot.data.y > window.innerHeight) dot.data.y = window.innerHeight;
            });
        }

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.key === 'a') { // Add more dots
                config.dotCount += 20;
                initDots(config.dotCount);
            } else if (e.key === 'r') { // Remove some dots
                config.dotCount = Math.max(20, config.dotCount - 20);
                initDots(config.dotCount);
            } else if (e.key === 'c') { // Change colors
                for (let i = 0; i < config.colors.length; i++) {
                    config.colors[i] = `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
                }
                dots.forEach(dot => {
                    dot.style.backgroundColor = config.colors[Math.floor(Math.random() * config.colors.length)];
                });
            }
        });

        // Initialize
        window.addEventListener('mousemove', trackCursor);
        window.addEventListener('resize', handleResize);
        window.addEventListener('mousedown', function(e) {
            // Create an explosion of dots at click position
            mouseX = e.clientX;
            mouseY = e.clientY;
            const cursor = document.querySelector('.cursor');
            cursor.classList.add('active');
            setTimeout(() => cursor.classList.remove('active'), 500);
            
            for(let i=0; i<15; i++) {
                const dot = createDot();
                dot.data.x = mouseX;
                dot.data.y = mouseY;
                dot.data.vx = randomBetween(-5, 5);
                dot.data.vy = randomBetween(-5, 5);
                dots.push(dot);
            }
        });
        initDots(config.dotCount);
        updateDots();
    </script>
</body>
</html>

